#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;

int findPar(int u, vector<int> &parent)
{
    if (parent[u] == u)
    {
        return u;
    }

    return parent[u] = findPar(parent[u], parent);
}

void unionn(int u, int v, vector<int> &parent, vector<int> &size)
{
    u = findPar(u, parent);
    v = findPar(v, parent);

    if (u != v)
    {
        if (size[u] < size[v])
        {
            parent[u] = v;
            size[v] += size[u];
        }

        else // for(u>u or u==v size )
        {
            parent[v] = u;
            size[u] += size[v];
        }
    }
}

int minMalwareSpread(vector<vector<int>> &graph, vector<int> &initial)
{
    int n = graph.size();

    vector<int> parent(n);
    vector<int> size(n);

    for (int i = 0; i < n; i++)
    {
        parent[i] = i;
        size[i] = 1;
    }

    unordered_set<int> st;

    for (int s : initial)
    {
        st.insert(s);
    }

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (graph[i][j] == 1 and st.find(i) == st.end() and st.find(j) == st.end()) // only insert those who have no malware
            {
                unionn(i, j, parent, size);
            }
        }
    }

    unordered_map<int, unordered_set<int>> mp;

    vector<int> infected(n);

    for (int u : initial)
    {
        for (int j = 0; j < n; j++)
        {
            if (graph[u][j] == 1 and u != j)
            {
                int p = findPar(j, parent);

                mp[u].insert(p);
            }
        }
    }
}



class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<int> roots(n);
        for (auto i = 0; i < n; i++) roots[i] = i;
        
        auto find = [&](int id) {
            while (roots[id] != id) {
                roots[id] = roots[roots[id]];
                id = roots[id];
            }
            return id;
        };
        
        // Consider non-malware nodes
        vector<int> clean;
        set<int> initial_set(initial.begin(), initial.end());
        for (auto i = 0; i < n; i++)
            if (!initial_set.count(i)) clean.push_back(i);
        
        // Union Find on non-malware nodes
        for (auto i : clean)
            for (auto j : clean)
                if (i != j && graph[i][j])
                    roots[find(i)] = find(j);
        
        // Size of each group
        vector<int> area(n, 0);
        for (auto i : clean) area[find(i)]++;
        
        map<int, set<int>> infect_node; // malware -> nodes infected
        map<int, int> infect_count; // node -> # of infecting malware
        for (auto i : initial) {
            for (auto j : clean) {
                if (graph[i][j]) infect_node[i].insert(find(j));
            }
            for (auto j : infect_node[i])
                infect_count[j] += 1;
        }
        
        // Try remove each malware
        int res = initial[0], max_cnt = -1;
        for (auto& [malware, nodes] : infect_node) {
            int count = 0;
            for (auto& node : nodes) {
                // Only effective when node is infected by one malware
                if (infect_count[node] == 1)
                    count += area[node];
            }
            if (count > max_cnt || (count >= max_cnt && malware < res)) {
                max_cnt = count;
                res = malware;
            }
        }
        
        return res;
    }
};


int main()
{

    return 0;
}