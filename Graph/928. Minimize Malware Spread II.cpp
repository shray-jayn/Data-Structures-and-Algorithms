#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;

class Solution
{
public:
    vector<int> parent;
    vector<int> Size;

    int findParent(int x)
    {
        if (parent[x] == x)
            return x;

        return parent[x] = findParent(parent[x]);
    }

    // We are not defining rank here as usual as we want the size
    // of a particular group so whenever we merge we increment the size of its parent
    void Union(int u, int v)
    {
        if (Size[u] == Size[v])
        {
            parent[u] = v;
            Size[v]++;
        }
        else if (Size[u] > Size[v])
        {
            parent[v] = u;
            Size[u]++;
        }
        else if (Size[u] < Size[v])
        {
            parent[u] = v;
            Size[v]++;
        }
    }

    int minMalwareSpread(vector<vector<int>> &graph, vector<int> &initial)
    {
        // initially we would not union nodes which are from initial vector
        int n = graph.size();

        parent.resize(n);
        Size.resize(n, 1);

        for (int i = 0; i < n; i++)
        {
            parent[i] = i;
        }

        // set to store infected nodes
        set<int> st;
        for (auto e : initial)
        {
            st.insert(e);
        }

        // build the components
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (graph[i][j] == 1 and find(st.begin(), st.end(), i) == st.end() and
                    find(st.begin(), st.end(), j) == st.end())
                {
                    int p1 = findParent(i);
                    int p2 = findParent(j);

                    if (p1 != p2)
                    {
                        Union(p1, p2);
                    }
                }
            }
        }

        // now for every infected node we will store the corresponding neighbours's leader
        // of the group
        unordered_map<int, set<int>> map;

        // make an infected vector to see if a particular group has more than 1 infected nodes
        // as in that case the removal of the node would be useless as the other node
        // would infect the others

        // also while removing nodes we should consider that by removal of one infected node
        // we do not remove another infected nodes which is possible when two infected nodes
        // are neighbours (it would violate that we have to remove only one infected node)

        vector<int> infected(n);

        for (auto u : initial)
        {
            for (int j = 0; j < n; j++)
            {
                if (graph[u][j] == 1 and u != j and find(st.begin(), st.end(), j) == st.end())
                {
                    int p = findParent(j);
                    // the map should not be having the parent already
                    if (find(map[u].begin(), map[u].end(), p) == map[u].end())
                    {
                        map[u].insert(p);
                        infected[p]++;
                    }
                }
            }
        }

        int ans = -1;
        int maxi = -1;

        for (int u : initial)
        {
            set<int> pars = map[u];

            int total = 0;

            for (auto p : pars)
            {
                // only those groups having 1 infected node will be considered
                if (infected[p] == 1)
                {
                    total += Size[p];
                }
            }

            if (total >= maxi)
            {
                if (total == maxi)
                {
                    ans = min(ans, u);
                }
                else
                {
                    ans = u;
                }
                maxi = total;
            }
        }
        if (ans == -1)
        {
            int mini = INT_MAX;
            for (auto e : initial)
            {
                mini = min(mini, e);
            }
            return mini;
        }
        return ans;
    }
};

int main()
{

    return 0;
}